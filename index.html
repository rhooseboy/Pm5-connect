<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Concept2 Bio-Dashboard v9 (Biomechanics)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    
    <!-- MediaPipe Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background-color: #0b0f19;
            color: #e5e7eb;
        }
        
        .metric-card {
            background: #111827;
            border: 1px solid #1f2937;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
        }

        .lcd-text {
            color: #60a5fa;
            text-shadow: 0 0 10px rgba(96, 165, 250, 0.5);
        }

        canvas {
            border-radius: 0.5rem;
        }

        .video-container {
            position: relative;
            overflow: hidden;
            border-radius: 0.75rem;
            border: 1px solid #374151;
            background: #000;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
        }
        
        /* The raw video is hidden, we draw on the canvas output */
        .input_video {
            display: none;
        }
        
        .output_canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
            /* transform: scaleX(-1); Mirror effect optional */ 
        }

        .overlay-badge {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col p-4">

    <!-- Header & Controls -->
    <header class="flex justify-between items-center mb-4">
        <div>
            <h1 class="text-xl font-bold text-white tracking-tighter">BIO<span class="text-blue-500">_DASH</span> <span class="text-xs text-green-400 align-top">v9</span></h1>
        </div>
        <div class="flex gap-2">
            <button id="camBtn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs font-bold py-2 px-4 rounded transition-all">
                Start AI Cam
            </button>
            <button id="connectBtn" class="bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-2 px-4 rounded flex items-center gap-2 transition-all shadow-lg shadow-blue-900/50">
                Connect PM5
            </button>
        </div>
    </header>

    <!-- Main Grid -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 flex-grow">
        
        <!-- Left Column: Camera & Metrics -->
        <div class="flex flex-col gap-4">
            
            <!-- Camera View -->
            <div class="video-container h-64 lg:h-96 relative">
                <video class="input_video"></video>
                <canvas class="output_canvas" id="output_canvas"></canvas>
                
                <!-- HUD Overlays -->
                <div class="absolute top-2 left-2 overlay-badge px-3 py-1 rounded text-xs text-green-400 font-mono border border-green-900/50 flex gap-2">
                    <span id="aiStatus">AI READY</span>
                </div>

                <div class="absolute bottom-2 right-2 overlay-badge px-3 py-2 rounded text-right border border-blue-900/50">
                    <div class="text-[10px] text-gray-400 uppercase">Torso Angle</div>
                    <div class="text-xl font-bold text-white" id="torsoAngle">--°</div>
                </div>
            </div>

            <!-- Key Metrics Row -->
            <div class="grid grid-cols-3 gap-2">
                <div class="metric-card rounded-lg p-3 flex flex-col items-center justify-center">
                    <span class="text-gray-500 text-[10px] uppercase">Watts</span>
                    <span id="watts" class="text-2xl font-bold text-white lcd-text">0</span>
                </div>
                <div class="metric-card rounded-lg p-3 flex flex-col items-center justify-center">
                    <span class="text-gray-500 text-[10px] uppercase">Rate</span>
                    <span id="spm" class="text-2xl font-bold text-white lcd-text">0</span>
                </div>
                <div class="metric-card rounded-lg p-3 flex flex-col items-center justify-center">
                    <span class="text-gray-500 text-[10px] uppercase">Pace</span>
                    <span id="pace" class="text-xl font-bold text-white lcd-text">0:00</span>
                </div>
            </div>
        </div>

        <!-- Right Column: Force Curve & Details -->
        <div class="flex flex-col gap-4">
            
            <!-- Force Curve Chart -->
            <div class="metric-card rounded-xl p-4">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-sm font-semibold text-gray-400">Force Curve</h3>
                    <div class="flex items-center gap-2">
                        <div id="strokeIndicator" class="w-2 h-2 rounded-full bg-gray-700"></div>
                        <span class="text-[10px] text-gray-600">PM5: 0x003D</span>
                    </div>
                </div>
                <!-- FIXED HEIGHT CONTAINER -->
                <div class="relative w-full h-48">
                    <canvas id="forceChart"></canvas>
                </div>
            </div>

            <!-- Biomechanics Data (New) -->
            <div class="grid grid-cols-2 gap-2">
                <div class="metric-card rounded-xl p-3">
                    <span class="text-[10px] text-gray-500 uppercase block">Drive Length</span>
                    <span id="driveLength" class="text-lg font-mono text-purple-400">-- m</span>
                </div>
                <div class="metric-card rounded-xl p-3">
                    <span class="text-[10px] text-gray-500 uppercase block">Drive Time</span>
                    <span id="driveTime" class="text-lg font-mono text-purple-400">-- s</span>
                </div>
            </div>

            <!-- Detailed Stats -->
            <div class="metric-card rounded-xl p-4 text-xs font-mono text-gray-400">
                <div class="flex justify-between border-b border-gray-800 py-1">
                    <span>Distance</span>
                    <span id="distance" class="text-white">0 m</span>
                </div>
                <div class="flex justify-between border-b border-gray-800 py-1">
                    <span>Drag Factor</span>
                    <span id="dragFactor" class="text-yellow-400">--</span>
                </div>
                <div class="flex justify-between border-b border-gray-800 py-1">
                    <span>Heart Rate</span>
                    <span id="heartRate" class="text-red-400">--</span>
                </div>
                <div class="pt-2 text-[10px] text-gray-600 truncate" id="statusLog">
                    System Ready.
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // 1. MEDIAPIPE POSE (AI LAYER)
        // ==========================================
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementsByClassName('output_canvas')[0];
        const canvasCtx = canvasElement.getContext('2d');
        const camBtn = document.getElementById('camBtn');
        let camera = null;
        let isCameraRunning = false;

        function onResults(results) {
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.poseLandmarks) {
                drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS,
                             {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, results.poseLandmarks,
                            {color: '#FF0000', lineWidth: 1, radius: 3});
                
                const leftVis = results.poseLandmarks[11].visibility * results.poseLandmarks[23].visibility;
                const rightVis = results.poseLandmarks[12].visibility * results.poseLandmarks[24].visibility;
                let top, bottom;
                if (leftVis > rightVis) {
                    top = results.poseLandmarks[11]; // Left Shoulder
                    bottom = results.poseLandmarks[23]; // Left Hip
                } else {
                    top = results.poseLandmarks[12]; // Right Shoulder
                    bottom = results.poseLandmarks[24]; // Right Hip
                }

                const deltaX = top.x - bottom.x;
                const deltaY = top.y - bottom.y; 
                const rad = Math.atan2(deltaX, -deltaY);
                let deg = Math.round(rad * (180 / Math.PI));
                
                const angleDisplay = document.getElementById('torsoAngle');
                angleDisplay.innerText = deg + "°";
                
                if(deg > 30) angleDisplay.style.color = "orange";
                else if(deg < -35) angleDisplay.style.color = "red";
                else angleDisplay.style.color = "white";
            }
            canvasCtx.restore();
        }

        const pose = new Pose({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
        }});

        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        pose.onResults(onResults);

        camBtn.addEventListener('click', () => {
            if (isCameraRunning) {
                if(camera) camera.stop();
                isCameraRunning = false;
                camBtn.innerText = "Start AI Cam";
                camBtn.classList.replace('bg-red-600', 'bg-gray-700');
                document.getElementById('aiStatus').innerText = "AI PAUSED";
            } else {
                document.getElementById('aiStatus').innerText = "LOADING AI...";
                camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await pose.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });
                camera.start();
                isCameraRunning = true;
                camBtn.innerText = "Stop AI Cam";
                camBtn.classList.replace('bg-gray-700', 'bg-red-600');
                document.getElementById('aiStatus').innerText = "AI ACTIVE";
            }
        });


        // ==========================================
        // 2. BLUETOOTH (DATA LAYER)
        // ==========================================
        const PM5_ROWING_SERVICE_UUID = 'ce060030-43e5-11e4-916c-0800200c9a66';
        const CHAR_GENERAL_STATUS = 'ce060031-43e5-11e4-916c-0800200c9a66'; 
        const CHAR_ADDITIONAL_STATUS_1 = 'ce060032-43e5-11e4-916c-0800200c9a66'; 
        const CHAR_STROKE_DATA = 'ce060035-43e5-11e4-916c-0800200c9a66'; // Biomechanics (Drive Length etc)
        const CHAR_FORCE_CURVE = 'ce06003d-43e5-11e4-916c-0800200c9a66'; 
        
        let bluetoothDevice;
        let forceCurvePoints = [];
        let lastForceTime = 0;

        // Chart Setup
        const ctx = document.getElementById('forceChart').getContext('2d');
        let gradient = ctx.createLinearGradient(0, 0, 0, 400);
        gradient.addColorStop(0, 'rgba(96, 165, 250, 0.5)');
        gradient.addColorStop(1, 'rgba(96, 165, 250, 0.0)');

        const forceChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: Array.from({length: 60}, (_, i) => i),
                datasets: [{
                    label: 'Force',
                    data: [],
                    borderColor: '#60a5fa',
                    backgroundColor: gradient,
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: { duration: 0 },
                scales: {
                    x: { display: false },
                    y: { 
                        beginAtZero: true,
                        grid: { color: '#1f2937' },
                        ticks: { display: false }
                    }
                },
                plugins: { legend: { display: false } }
            }
        });

        // Connection Logic
        document.getElementById('connectBtn').addEventListener('click', async () => {
            log('Scanning...');
            try {
                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: 'PM5' }],
                    optionalServices: [PM5_ROWING_SERVICE_UUID]
                });

                const server = await bluetoothDevice.gatt.connect();
                const service = await server.getPrimaryService(PM5_ROWING_SERVICE_UUID);

                // 1. General Status
                const generalChar = await service.getCharacteristic(CHAR_GENERAL_STATUS);
                await generalChar.startNotifications();
                generalChar.addEventListener('characteristicvaluechanged', handleGeneralStatus);

                // 2. Additional Status (Watts/Pace)
                const addChar1 = await service.getCharacteristic(CHAR_ADDITIONAL_STATUS_1);
                await addChar1.startNotifications();
                addChar1.addEventListener('characteristicvaluechanged', handleAdditionalStatus1);

                // 3. Stroke Data (Biomechanics)
                try {
                    const strokeChar = await service.getCharacteristic(CHAR_STROKE_DATA);
                    await strokeChar.startNotifications();
                    strokeChar.addEventListener('characteristicvaluechanged', handleStrokeData);
                    log('Subscribed to Stroke Data');
                } catch(e) { log('No Stroke Data'); }

                // 4. Force Curve
                try {
                    const forceChar = await service.getCharacteristic(CHAR_FORCE_CURVE);
                    await forceChar.startNotifications();
                    forceChar.addEventListener('characteristicvaluechanged', handleForceCurve);
                } catch(e) { log('No Force Curve'); }

                document.getElementById('connectBtn').innerHTML = `<span class="text-green-200">●</span> PM5`;
                document.getElementById('connectBtn').classList.replace('bg-blue-600', 'bg-green-700');
                log('System Fully Online.');

            } catch (error) {
                log('BT Error: ' + error);
            }
        });

        // Bluetooth Parsers
        function handleGeneralStatus(event) {
            const value = event.target.value;
            const dist = (value.getUint8(3) | (value.getUint8(4) << 8) | (value.getUint8(5) << 16)) * 0.1;
            document.getElementById('distance').innerText = Math.floor(dist) + " m";
            document.getElementById('spm').innerText = value.getUint8(8);
        }

        function handleAdditionalStatus1(event) {
            const value = event.target.value;
            const w = (value.getUint8(3) | (value.getUint8(4) << 8));
            if(w < 2000) document.getElementById('watts').innerText = w;

            const p = (value.getUint8(9) | (value.getUint8(10) << 8));
            if(p > 0 && p < 60000) document.getElementById('pace').innerText = formatTime(p * 0.01);

            const hr = value.getUint8(7);
            if(hr > 0 && hr < 240 && hr !== 255) document.getElementById('heartRate').innerText = hr;
        }

        function handleStrokeData(event) {
            const value = event.target.value;
            // Layout typically: [Elapsed(3)] [Distance(3)?] [DriveLength(1)] [DriveTime(1)]
            // C2 Stroke Data Spec usually:
            // Bytes 5-6: Drive Length (0.01m)
            // Bytes 7-8: Drive Time (0.01s)
            // Bytes 11-12: Stroke Distance (0.01m) 
            // Bytes 17: Drag Factor (sometimes)
            
            if (value.byteLength > 8) {
                // Drive Length
                const driveLenRaw = value.getUint8(5) | (value.getUint8(6) << 8);
                const driveLenM = driveLenRaw * 0.01;
                document.getElementById('driveLength').innerText = driveLenM.toFixed(2) + " m";

                // Drive Time
                const driveTimeRaw = value.getUint8(7) | (value.getUint8(8) << 8);
                const driveTimeS = driveTimeRaw * 0.01;
                document.getElementById('driveTime').innerText = driveTimeS.toFixed(2) + " s";
            }
            
            // Drag Factor check (sometimes at byte 17, simplified check)
            /*
            if (value.byteLength > 17) {
                const drag = value.getUint8(17);
                if(drag > 0) document.getElementById('dragFactor').innerText = drag;
            }
            */
        }
        
        function handleForceCurve(event) {
            const value = event.target.value;
            const now = Date.now();
            
            if (now - lastForceTime > 700) {
                resetGraph();
            }
            lastForceTime = now;

            for (let i = 0; i < value.byteLength; i += 2) {
                if (i + 1 < value.byteLength) {
                    forceCurvePoints.push(value.getUint16(i, true));
                }
            }
            
            forceChart.data.datasets[0].data = forceCurvePoints;
            forceChart.update();
        }

        function resetGraph() {
            forceCurvePoints = [];
            forceChart.data.datasets[0].data = [];
            forceChart.update();
            const ind = document.getElementById('strokeIndicator');
            ind.classList.add('bg-green-400');
            setTimeout(() => ind.classList.remove('bg-green-400'), 100);
        }

        function formatTime(s) {
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            return `${m}:${sec.toString().padStart(2,'0')}`;
        }

        function log(m) {
            document.getElementById('statusLog').innerText = m;
        }
        
        async function wakeLock() {
            try { await navigator.wakeLock.request('screen'); } catch(e){}
        }
        document.addEventListener('click', wakeLock);

    </script>
</body>
</html>
